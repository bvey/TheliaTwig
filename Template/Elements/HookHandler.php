<?php
/*************************************************************************************/
/*      This file is part of the Thelia package.                                     */
/*                                                                                   */
/*      Copyright (c) OpenStudio                                                     */
/*      email : dev@thelia.net                                                       */
/*      web : http://www.thelia.net                                                  */
/*                                                                                   */
/*      For the full copyright and license information, please view the LICENSE.txt  */
/*      file that was distributed with this source code.                             */
/*************************************************************************************/


namespace TheliaTwig\Template\Elements;

use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;
use Thelia\Core\Event\Hook\HookRenderBlockEvent;
use Thelia\Core\Event\Hook\HookRenderEvent;
use Thelia\Core\Hook\FragmentBag;
use Thelia\Core\HttpFoundation\Request;
use Thelia\Core\Template\ParserInterface;
use Thelia\Core\Translation\Translator;
use Thelia\Model\ModuleQuery;


/**
 * Class HookHandler
 * @package TheliaTwig\Template\Elements
 * @author Julien ChansÃ©aume <julien@thelia.net>
 */
class HookHandler
{
    /** @var ContainerInterface */
    protected $container;

    /** @var EventDispatcherInterface */
    private $dispatcher;

    /** @var Translator */
    protected $translator;

    /** @var ParserInterface */
    protected $parser;

    /** @var Request */
    protected $request;

    /** @var array */
    protected $hookResults = array();

    /** @var array */
    protected $varStack = array();

    /** @var bool debug */
    protected $debug = false;

    public function __construct(ContainerInterface $container, $debug)
    {
        $this->debug = (bool)$debug;

        $this->dispatcher = $container->get('event_dispatcher');
        $this->parser = $container->get("thelia.parser");
        $this->translator = $container->get("thelia.translator");
        $this->request = $container->get("request");

        $this->hookResults = array();
    }

    /**
     * Generates the content of the hook
     *
     * {% hook {name: "hook_code", var1: "value1", var2: "value2", ... } %}
     *
     * This function create an event, feed it with the custom variables passed to the function (var1, var2, ...) and
     * dispatch it to the hooks that respond to it.
     *
     * The name of the event is `hook.{context}.{hook_code}` where :
     *      * context : the id of the context of the render : 1: frontoffice, 2: backoffice, 3: email, 4: pdf
     *      * hook_code : the code of the hook
     *
     * The event collects all the fragments of text rendered in each modules functions that listen to this event.
     * Finally, this fragments are concatenated and injected in the template
     *
     * @param array $context the twig context
     * @param array $params the params passed in the function
     *
     * @return string the contents generated by modules
     */
    public function processHookFunction(&$context, $params)
    {
        $hookName = $this->getParam($params, 'name');
        $module = intval($this->getParam($params, 'module', 0));
        $moduleCode = $this->getParam($params, 'modulecode', "");

        $type = $this->parser->getTemplateDefinition()->getType();

        $event = new HookRenderEvent($hookName, $params);

        $event->setArguments($this->getArgumentsFromParams($params));

        $eventName = sprintf('hook.%s.%s', $type, $hookName);

        // this is a hook specific to a module
        if (0 === $module && "" !== $moduleCode) {
            if (null !== $mod = ModuleQuery::create()->findOneByCode($moduleCode)) {
                $module = $mod->getId();
            }
        }
        if (0 !== $module) {
            $eventName .= '.' . $module;
        }

        $this->dispatcher->dispatch($eventName, $event);

        $content = trim($event->dump());

        if ($this->debug && $this->request && $this->request->get('SHOW_HOOK')) {
            $content = $this->showHook($hookName, $params) . $content;
        }

        $this->hookResults[$hookName] = $content;

        return $content;
    }


    /**
     * Process the content of the hook block.
     *
     * {% hookblock  {name: "hook_code", var1: "value1", var2: "value2", ...} %}
     *
     * This function create an event, feed it with the custom variables passed to the function (var1, var2, ...) and
     * dispatch it to the hooks that respond to it.
     *
     * The name of the event is `hook.{context}.{hook_code}` where :
     *      * context : the id of the context of the render : 1: frontoffice, 2: backoffice, 3: email, 4: pdf
     *      * hook_code : the code of the hook
     *
     * The event collects all the fragments generated by modules that listen to this event and add it to a fragmentBag.
     * This fragmentBag is not used directly. This is the forhook block that iterates over the fragmentBag to inject
     * data in the template.
     *
     * @param array $context the twig context
     * @param array $params the params passed in the function
     *
     * @return string the generated content of the hook documentation. The real content is  displayed by the `forhook` tag
     */
    public function processHookBlock(&$context, $params)
    {
        $content = '';
        $hookName = $this->getParam($params, 'name');
        $module = intval($this->getParam($params, 'module', 0));
        // explicit definition of variable that can be returned
        $fields = preg_replace(
            '|[^a-zA-Z0-9,\-_]|',
            '',
            $this->getParam($params, 'fields', '')
        );
        $fields = ('' !== $fields) ? explode(",", $fields) : [];

        $type = $this->parser->getTemplateDefinition()->getType();

        $event = new HookRenderBlockEvent($hookName, $params, $fields);

        $event->setArguments($this->getArgumentsFromParams($params));

        $eventName = sprintf('hook.%s.%s', $type, $hookName);

        // this is a hook specific to a module
        if (0 !== $module) {
            $eventName .= '.' . $module;
        }

        $this->dispatcher->dispatch($eventName, $event);

        // save results so we can use it in forHook block
        $this->hookResults[$hookName] = $event->get();

        if ($this->debug && $this->request && $this->request->get('SHOW_HOOK')) {
            $content = $this->showHook($hookName, $params);
        }

        return $content;
    }

    /**
     * Process a {% forhook {rel: "hookname"} %} ... {% endforhook %}
     *
     * The forhook iterates over the results return by a hookblock :
     *
     * {% hookblock {name: "product.additional"} %}
     * {% forhook {rel: "product.additional"} %}
     *     <div id="{{ id }}">
     *         <h2>{{ title }}</h2>
     *         <p>{{ content }}</p>
     *     </div>
     * {% endforhook %}
     *
     *
     * @param array $context the twig context
     * @param array $params
     * @param boolean $repeat
     * @param boolean $first true for the first call of the function
     * @param array $_context the initial twig context (only available on the first call)
     *
     * @throws \InvalidArgumentException
     */
    public function processForHookBlock(&$context, $params, &$repeat, $first, $_context = null)
    {
        $rel = $this->getParam($params, 'rel');
        if (null == $rel) {
            throw new \InvalidArgumentException(
                $this->translator->trans("Missing 'rel' parameter in forHook arguments")
            );
        }

        if (!array_key_exists($rel, $this->hookResults)) {
            throw new \InvalidArgumentException(
                $this->translator->trans("Related hook name '%name' is not defined.", ['%name' => $rel])
            );
        }


        /** @var FragmentBag $fragments */
        $fragments = $this->hookResults[$rel];

        if ($first) {
            if ($fragments->isEmpty()) {
                $repeat = false;
                return;
            } else {
                $this->varStack[$rel] = $_context;
                $fragments->rewind();
            }
        } else {
            $fragments->next();
        }

        if ($fragments->valid()) {
            $fragment = $fragments->current();

            $this->assignContext($context, $fragment->getVarVal());
            // continue iteration
            $repeat = true;
        } else {
            $repeat = false;

            $context = $this->varStack[$rel];
        }
    }

    /**
     * Generate a description of the hook to help the developer. This description is prepend to the content of
     * the `hook` or `hookblock` content.
     *
     * @param $hookName
     * @param $params
     * @return string
     */
    protected function showHook($hookName, $params)
    {
        $content = '<div style="background-color: #C82D26; color: #fff; border-color: #000000; border: solid;">' . $hookName;

        foreach ($params as $name => $value) {
            if ($name !== 'location' && $name !== "name") {
                $type = '';
                if (is_object($value)) {
                    $value = get_class($value);
                    $type = 'object';
                } elseif (is_array($value)) {
                    $value = implode(',', $value);
                    $type = 'array';
                } elseif (is_int($value)) {
                    $type = 'float';
                } elseif (is_int($value)) {
                    $type = 'int';
                } elseif (is_string($value)) {
                    $value = (strlen($value) > 30) ? substr($value, 0, 30) . '...' : $value;
                    $type = 'string';
                }

                if ($type !== '') {
                    $type = '<span style="background-color: #FF7D00; color: #fff">' . $type . '</span> ';
                }

                $content .= '<span style="background-color: #008000; color: #fff; margin-left: 6px;">' . $name . ' = ' . $type . $value . '</span>';
            }
        }

        return $content . '</div>';
    }

    protected function assignContext(&$context, array $vars)
    {
        foreach ($vars as $var => $val) {
            $context[$var] = $val;
        }
    }

    /**
     * Check if a hook has returned results. The hook should have been executed before, or an
     * InvalidArgumentException is thrown
     *
     * @param array $params
     *
     * @return boolean                   true if the hook is empty
     * @throws \InvalidArgumentException
     */
    public function checkEmptyHook($params)
    {
        $hookName = $this->getParam($params, 'rel');

        if (null == $hookName) {
            throw new \InvalidArgumentException(
                $this->translator->trans("Missing 'rel' parameter in ifhook/elsehook arguments")
            );
        }

        if (!isset($this->hookResults[$hookName])) {
            throw new \InvalidArgumentException(
                $this->translator->trans("Related hook name '%name' is not defined.", ['%name' => $hookName])
            );
        }

        return (is_string($this->hookResults[$hookName]) && '' === $this->hookResults[$hookName]
            || !is_string($this->hookResults[$hookName]) && $this->hookResults[$hookName]->isEmpty()
        );
    }

    /**
     * Clean the params of the params passed to the hook function or block to feed the arguments of the event
     * with relevant arguments.
     *
     * @param   $params
     *
     * @return array
     */
    protected function getArgumentsFromParams($params)
    {
        $args = array();
        $excludes = array("name", "before", "separator", "after", "fields");

        if (is_array($params)) {
            foreach ($params as $key => $value) {
                if (!in_array($key, $excludes)) {
                    $args[$key] = $value;
                }
            }
        }

        return $args;
    }

    /**
     * Get a function or block parameter value
     *
     * @param  array $params the parameters array
     * @param  mixed $name as single parameter name, or an array of names. In this case, the first defined parameter is returned. Use this for aliases (context, ctx, c)
     * @param  mixed $default the defaut value if parameter is missing (default to null)
     * @return mixed the parameter value, or the default value if it is not found.
     */
    public function getParam($params, $name, $default = null)
    {
        if (is_array($name)) {
            foreach ($name as $test) {
                if (isset($params[$test])) {
                    return $params[$test];
                }
            }
        } elseif (isset($params[$name])) {
            return $params[$name];
        }

        return $default;
    }
}